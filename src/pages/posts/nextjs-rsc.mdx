---
title: "Next.js에서 서버 컴포넌트를 어떻게 읽고 화면에 렌더링을 할까?"
date: "2025-09-04"
tags: ["Next.js", "React", "ServerComponent", "RSC Payload"]
layout: "../../components/Layout.astro"
---

> Next.js에서 서버 컴포넌트를 어떻게 읽고 화면에 렌더링을 할까?

---

### 이 내용을 선정하게 된 이유

Next.js에서 서버 컴포넌트를 사용하면 여러 이점들을 공식 문서나 블로그에서 확인할 수 있습니다. 저는 그중에서도 "JS 번들 크기가 줄어드는 메커니즘과 렌더링 방식"이 궁금했습니다. 이 원리를 이해하려면 먼저 서버 컴포넌트가 무엇인지 간단히 살펴보는 것이 필요합니다.

---

### 서버 컴포넌트가 무엇인지 간략하게 알아볼게요

서버 컴포넌트는 브라우저에서 실행되는 일반 컴포넌트와 달리, 서버에서 실행된 뒤 HTML로 변환되어 클라이언트로 전달되는 컴포넌트를 의미합니다. 처음 접하면 "서버에서 React 컴포넌트를 직접 읽는다고?" 라는 의문이 들 수 있습니다. 이때 등장하는 핵심 개념이 바로 `RSC Payload`입니다. 이제 이 구조를 조금 더 자세히 들여다보겠습니다.

---

### RSC(React Server Component) Payload

RSC Payload는 서버 컴포넌트 실행 결과를 직렬화한 데이터 형식입니다. 개발 중 네트워크 탭에서 `https://domain.com?_rsc=194na`와 같은 요청 응답을 본 적이 있다면, 아래와 같은 형태를 확인했을 수 있습니다.

```ts
["$", "div", null, ["$", "h1", null, "List"], ["$C", "List", {}]];
```

이 Payload는 클라이언트 React가 읽어 DOM을 업데이트하는 데 사용됩니다. 내부에는 다음과 같은 정보가 포함됩니다.

* 서버 컴포넌트 렌더링 결과
* 클라이언트에서 필요한 JS 파일 참조 정보
* 컴포넌트에 전달되는 props 정보

> [What is the React Server Component Payload (RSC)?](https://nextjs.org/docs/app/getting-started/server-and-client-components#on-the-server)

Next.js 13부터는 서버 컴포넌트를 활용해 RSC Payload를 스트리밍 방식으로 전달할 수 있고, 이를 통해 사용자는 빠르게 초기 화면을 볼 수 있습니다. 반면 Next.js 12에서는 모든 컴포넌트가 클라이언트 중심이라 이러한 최적화가 불가능했습니다.

그렇다면 RSC Payload는 언제 생성되고, HTML과는 어떤 방식으로 함께 동작할까요?

---

### 렌더링 과정

렌더링은 크게 세 단계로 나눌 수 있습니다.

1. **서버 컴포넌트 실행 → RSC Payload 생성**
   서버는 React Server Components를 실행하면서 클라이언트 경계, props, 데이터 등을 Flight 포맷으로 직렬화하여 Payload를 생성합니다. 이 Payload는 클라이언트가 컴포넌트를 동적으로 불러오는 데 활용됩니다. (SEO 크롤러는 직접 읽지 못합니다.)

2. **서버에서 HTML 스트리밍 생성 (`renderToPipeableStream`)**
   동시에 서버는 동일한 트리를 기반으로 HTML shell을 스트리밍합니다. Suspense 경계를 기준으로 Fallback → 준비된 블록 순서대로 전달되며, 브라우저나 크롤러는 이 HTML을 즉시 받아 빠른 FCP(First Contentful Paint)를 얻을 수 있습니다.

3. **클라이언트에서 하이드레이션**
   브라우저는 서버가 내려준 HTML을 먼저 렌더링한 뒤, RSC Payload를 fetch하여 필요한 클라이언트 컴포넌트를 불러옵니다. React는 이를 기존 HTML과 결합해 상호작용 가능한 UI로 완성합니다.

React 18의 `renderToPipeableStream`은 Next.js 13 내부에서도 동일하게 동작합니다.

```tsx
import { renderToPipeableStream } from "react-dom/server";

const { pipe } = renderToPipeableStream(<App />, {
  bootstrapScripts: ["/main.js"],
  onShellReady() {
    response.setHeader("content-type", "text/html");
    pipe(response);
  },
});
```

> [renderToPipeableStream](https://ko.react.dev/reference/react-dom/server/renderToPipeableStream)

> [How to upgrade to version 13](https://nextjs.org/docs/pages/guides/upgrading/version-13)


이 과정을 통해 브라우저는 초기 HTML과 상호작용 가능한 UI를 모두 얻게 됩니다. 그렇다면 서버 컴포넌트 자체는 어디에 저장되고 실행될까요?

---

### 서버 컴포넌트 위치

서버 컴포넌트는 클라이언트 번들에 포함되지 않습니다. 대신 빌드 타임에 서버와 클라이언트 경계에 따라 별도로 저장됩니다.

* 서버 컴포넌트: `.next/server/app/**`
* 클라이언트 컴포넌트(“use client”): `.next/static/chunks/**`

![서버컴포넌트 위치](/images/nextjs-rsc/server-component-position.webp)

이 구조 덕분에 서버는 실행된 결과(RSC Payload)를 클라이언트에 전달하고, 클라이언트는 필요한 최소한의 JS만 불러옵니다. 이는 곧 클라이언트 JS 번들 최적화로 이어집니다.

---

### 클라이언트 JS 번들 최적화

Next.js 12에서는 모든 컴포넌트가 클라이언트 번들에 포함되어 번들 크기가 커졌습니다. 하지만 Next.js 13(Server Components)에서는 다음과 같은 차이가 있습니다.

* 서버 컴포넌트는 JS 번들에 포함되지 않음
* 클라이언트 컴포넌트만 실제 브라우저에서 필요한 JS로 번들링

이 차이 덕분에 전체 JS 크기를 줄이고 초기 로딩 성능을 개선할 수 있습니다. 즉, **JS 번들 크기 최적화**의 핵심 원리가 됩니다.

---

### 정리

Next.js 13의 서버 컴포넌트는 **서버와 클라이언트의 책임을 분리**하여 다음과 같은 이점을 제공합니다.

* JS 번들 크기 감소
* 스트리밍 렌더링으로 빠른 초기 화면 제공
* 필요한 클라이언트 컴포넌트만 하이드레이션

이번에 내용을 정리하면서 단순히 **서버에서 HTML을 내려준다** 정도로 이해했던 수준을 넘어, 실제 **RSC Payload와 스트리밍 메커니즘이 어떻게 맞물려 동작하는지**를 확인할 수 있었습니다. 이를 통해 프레임워크 내부 동작을 조금 더 깊이 이해할 수 있는 계기가 되었습니다.
