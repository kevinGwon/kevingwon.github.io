---
title: "Next.js에서 서버 컴포넌트를 어떻게 읽고 화면에 렌더링을 할까?"
date: "2025-09-04"
tags: ["Next.js", "React", "ServerComponent", "RSC Payload"]
layout: "../../components/Layout.astro"
---

> Next.js에서 서버 컴포넌트를 어떻게 읽고 화면에 렌더링을 할까?

---

### 이 내용을 선정하게 된 이유

Next.js에서 서버 컴포넌트를 사용하면 여러 이점들을 공식 문서나 블로그에서 확인할 수 있습니다. 저는 그중에서도 "JS 번들 크기가 줄어드는 메커니즘과 렌더링 방식"이 궁금했습니다. 이 원리를 이해하려면 먼저 서버 컴포넌트가 무엇인지 간단히 살펴보는 것이 필요합니다.

---

### 서버 컴포넌트가 무엇인지 간략하게 알아볼게요

서버 컴포넌트는 브라우저에서 실행되는 일반 컴포넌트와 달리, 서버에서 실행된 뒤 HTML로 변환되어 클라이언트로 전달되는 컴포넌트를 의미합니다. 처음 접하면 "서버에서 React 컴포넌트를 직접 읽는다고?" 라는 의문이 들 수 있습니다. 이때 등장하는 핵심 개념이 바로 `RSC Payload`입니다. 이제 이 구조를 조금 더 자세히 들여다보겠습니다.

---

### RSC(React Server Component) Payload

RSC Payload는 서버 컴포넌트 실행 결과를 직렬화한 데이터 형식입니다. 개발 중 네트워크 탭에서 `https://domain.com?_rsc=194na`와 같은 요청 응답을 본 적이 있다면, 아래와 같은 형태를 확인했을 수 있습니다.

```ts
["$", "div", null, ["$", "h1", null, "List"], ["$C", "List", {}]];
```

이 Payload는 클라이언트 React가 읽어 **Fiber 트리를 재구성하고 어떤 UI를 렌더링할지 결정하는 데** 사용됩니다. DOM 위치 교체는 직접 하지 않고, Fizz 스트림의 마커 정보를 기반으로 React가 최종적으로 반영합니다. 내부에는 다음과 같은 정보가 포함됩니다.

* 서버 컴포넌트 렌더링 결과
* 클라이언트에서 필요한 JS 파일 참조 정보
* 컴포넌트에 전달되는 props 정보

> [What is the React Server Component Payload (RSC)?](https://nextjs.org/docs/app/getting-started/server-and-client-components#on-the-server)

Next.js 13부터는 서버 컴포넌트를 활용해 RSC Payload를 스트리밍 방식으로 전달할 수 있고, 이를 통해 사용자는 빠르게 초기 화면을 볼 수 있습니다. 반면 Next.js 12에서는 모든 컴포넌트가 클라이언트 중심이라 이러한 최적화가 불가능했습니다.

그렇다면 RSC Payload는 언제 생성되고, HTML과는 어떤 방식으로 함께 동작할까요?

---

### 렌더링 과정

렌더링은 크게 세 단계로 나눌 수 있습니다.

1. **서버 컴포넌트 실행 → RSC Payload 생성** \
서버는 React Server Components를 실행하면서 클라이언트 경계, props, 데이터 등을 Flight 포맷으로 직렬화하여 Payload를 생성합니다. 이 Payload는 클라이언트가 컴포넌트를 동적으로 불러오는 데 활용됩니다. (SEO 크롤러는 직접 읽지 못합니다.)

2. **서버에서 HTML 스트리밍 생성 (`renderToPipeableStream`)** \
서버는 동일한 트리를 기반으로 최소한의 HTML 뼈대(HTML shell)를 먼저 스트리밍합니다. `<template>`과 `<!--$-->` 같은 Suspense 마커로 자리를 표시해 두고, 준비된 블록이 오면 해당 위치를 교체합니다. 브라우저는 이 뼈대를 즉시 렌더링해 빠른 FCP(First Contentful Paint)를 얻습니다. 크롤러는 주로 초기 HTML까지만 읽으므로 중요한 콘텐츠는 이 안에 포함하는 것이 SEO에 유리합니다.

3. **클라이언트에서 하이드레이션** \
이후 브라우저는 비동기 JS 청크와 함께 전달되는 RSC Payload를 받아 필요한 클라이언트 컴포넌트를 불러옵니다. React는 스트리밍된 마커 위치와 RSC Payload의 정보를 매칭시켜 Fiber 트리를 완성하고, 최종적으로 상호작용 가능한 UI로 하이드레이션합니다.

React 18의 `renderToPipeableStream`은 Next.js 13 내부에서도 동일하게 동작합니다.

```tsx
import { renderToPipeableStream } from "react-dom/server";

const { pipe } = renderToPipeableStream(<App />, {
  bootstrapScripts: ["/main.js"],
  onShellReady() {
    response.setHeader("content-type", "text/html");
    pipe(response);
  },
});
```

> [renderToPipeableStream](https://ko.react.dev/reference/react-dom/server/renderToPipeableStream)

> [How to upgrade to version 13](https://nextjs.org/docs/pages/guides/upgrading/version-13)


이 과정을 통해 브라우저는 초기 HTML과 상호작용 가능한 UI를 모두 얻게 됩니다. 그렇다면 서버 컴포넌트 자체는 어디에 저장되고 실행될까요?

---

### 서버 컴포넌트 위치

서버 컴포넌트는 클라이언트 번들에 포함되지 않습니다. 대신 빌드 타임에 서버와 클라이언트 경계에 따라 별도로 저장됩니다.

* 서버 컴포넌트: `.next/server/app/**`
* 클라이언트 컴포넌트(“use client”): `.next/static/chunks/**`

![서버컴포넌트 위치](/images/nextjs-rsc/server-component-position.webp)

이 구조 덕분에 서버는 실행된 결과(RSC Payload)를 클라이언트에 전달하고, 클라이언트는 필요한 최소한의 JS만 불러옵니다. 이는 곧 클라이언트 JS 번들 최적화로 이어집니다.

---

### 클라이언트 JS 번들 최적화

Next.js 12에서는 모든 컴포넌트가 클라이언트 번들에 포함되어 번들 크기가 커졌습니다. 하지만 Next.js 13(Server Components)에서는 다음과 같은 차이가 있습니다.

* 서버 컴포넌트는 JS 번들에 포함되지 않음
* 클라이언트 컴포넌트만 실제 브라우저에서 필요한 JS로 번들링

이 차이 덕분에 전체 JS 크기를 줄이고 초기 로딩 성능을 개선할 수 있습니다. 즉, **JS 번들 크기 최적화**의 핵심 원리가 됩니다.

---

### 정리

Next.js 13의 서버 컴포넌트는 **서버와 클라이언트의 책임을 분리**하여 다음과 같은 이점을 제공합니다.

* JS 번들 크기 감소
* 스트리밍 렌더링으로 빠른 초기 화면 제공
* 필요한 클라이언트 컴포넌트만 하이드레이션

이번에 내용을 정리하면서 단순히 **서버에서 HTML을 내려준다** 정도로 이해했던 수준을 넘어, 실제 **RSC Payload와 스트리밍 메커니즘이 어떻게 맞물려 동작하는지**를 확인할 수 있었습니다. 이를 통해 프레임워크 내부 동작을 조금 더 깊이 이해할 수 있는 계기가 되었습니다.
