---
title: "Next.js에서 서버 컴포넌트를 어떻게 읽고 화면에 렌더링을 할까?"
date: "2025-09-04"
tags: ["Next.js", "React", "ServerComponent", "RSC Payload"]
layout: "../../components/Layout.astro"
---

> Next.js에서 서버 컴포넌트를 어떻게 읽고 화면에 렌더링을 할까?

---

### 이 내용을 선정하게 된 이유

Next.js에서 서버 컴포넌트를 사용하면 여러 이점들을 공식 문서나 블로그에서 찾아볼 수 있습니다. 저는 그중에서 "JS 번들 크기가 줄어드는 메커니즘과 렌더링 방식이 궁금했습니다."

### 서버 컴포넌트가 무엇인지 간략하게 알아볼게요

서버 컴포넌트란 브라우저에서 렌더링되는 컴포넌트와 달리 서버에서 컴포넌트를 읽어 HTML로 변환한 후 클라이언트로 전달되는 컴포넌트를 의미합니다. 서버에서 React 컴포넌트를 직접 읽는다고 하면 의문이 생길 수 있습니다. 이 시점에 "RSC Payload"라는 개념이 등장하는데요, 자세히 분석해보겠습니다.

### RSC(React server component) Payload

RSC Payload는 렌더링된 서버 컴포넌트의 압축된 바이너리 표현입니다. 개발하다 보면 네트워크 탭에서 `https://domain.com?_rsc=194na`와 같은 요청에 대한 응답값을 다음과 같은 형태로 확인한 경험이 있을 겁니다.

```ts
["$", "div", null, ["$", "h1", null, "List"], ["$C", "List", {}]];
```

RSC Payload는 클라이언트로 응답값이 전달되고 클라이언트 측 React에서 RSC Payload를 읽어 브라우저 DOM을 업데이트하는 데 사용됩니다. RSC Payload는 다음 내용을 포함하고 있습니다.

- 서버 컴포넌트 렌더링 결과
- 클라이언트에 위치할 정보, JS 파일 참조 정보
- 컴포넌트에 전달되는 props 정보

참조: [What is the React Server Component Payload (RSC)?](https://nextjs.org/docs/app/getting-started/server-and-client-components#on-the-server)

Next.js 13 버전부터 서버 컴포넌트를 선택적으로 구성할 수 있고 RSC Payload 표현이 가능해지면서 스트리밍 렌더링을 지원하여 사용자에게 빠른 컨텐츠를 제공할 수 있습니다.

Next.js 12 버전의 경우 클라이언트 중심으로만 컴포넌트 구성이 가능하여 스트리밍 렌더링과 같은 전략을 제공할 수 없습니다.

이처럼 RSC Payload는 서버와 클라이언트 간 교환 형식입니다. 그렇다면 이 Payload는 언제 생성되고 HTML과는 어떻게 함께 동작할까요?

### 렌더링 과정

지금까지 RSC Payload가 무엇인지 간략하게 살펴보았는데요, 그렇다면 SEO에 제공되는 HTML 정보는 언제 생성될까요?

1. 서버 컴포넌트 실행 → RSC Payload 생성
   - 서버는 React Server Components를 실행하면서 클라이언트 컴포넌트 경계, props, 데이터 등을 Flight 포맷으로 직렬화하여 RSC Payload를 생성합니다.
   - 이 Payload는 브라우저가 클라이언트 컴포넌트를 동적으로 로드하고 상호작용을 이어가기 위한 용도입니다.
   - SEO 크롤러는 이 Payload를 직접 읽지 못합니다.

2. 서버에서 HTML 스트리밍 생성 (`renderToPipeableStream`)
   - 동시에 서버는 동일한 서버 컴포넌트 트리를 기반으로 SEO에 필요한 HTML shell을 renderToPipeableStream을 통해 스트리밍합니다.
   - 이때 Suspense 경계를 기준으로, Fallback → 준비된 블록 순으로 HTML이 조각 단위로 흘러갑니다.
   - 따라서 브라우저나 크롤러는 초기 HTML을 즉시 받아 빠른 FCP(First Contentful Paint)를 얻을 수 있습니다.

3. RSC Payload + 클라이언트에서 하이드레이션
   - 브라우저는 서버가 내려준 HTML을 즉시 렌더링한 뒤, RSC Payload를 fetch하여 필요한 클라이언트 컴포넌트를 로드합니다.
   - React는 이 Payload와 클라이언트 JS 번들을 조합해 기존 HTML을 hydrate하여 상호작용이 가능하도록 만듭니다.

React 18부터 추가된 `renderToPipeableStream`은 Next.js 13 내부에서도 동일하게 동작합니다. 이 메커니즘 덕분에 서버 컴포넌트 기반으로 HTML을 빠르게 생성하여 SEO 대응이 가능하고, 동시에 RSC Payload를 통해 상호작용 가능한 클라이언트 UI를 이어갈 수 있습니다.

```tsx
import { renderToPipeableStream } from "react-dom/server";

const { pipe } = renderToPipeableStream(<App />, {
  bootstrapScripts: ["/main.js"],
  onShellReady() {
    response.setHeader("content-type", "text/html");
    pipe(response);
  },
});
```

참조

- [How to upgrade to version 13](https://nextjs.org/docs/pages/guides/upgrading/version-13)
- [renderToPipeableStream](https://ko.react.dev/reference/react-dom/server/renderToPipeableStream)

이 과정을 통해 브라우저는 초기 HTML과 상호작용 가능한 UI를 모두 얻게 됩니다. 그렇다면 서버 컴포넌트 자체는 어디에 저장되고 실행될까요?

### 서버컴포넌트 위치

지금까지 클라이언트에 RSC Payload가 어떻게 전달되는지 과정을 살펴보았는데요, 그렇다면 서버컴포넌트는 번들 JS에 포함되지 않는다면 어디에 존재하고 있을까요? 바로 빌드 타임에 서버컴포넌트와 클라이언트컴포넌트 경계를 나누어 저장합니다.

- 서버 컴포넌트(RSC): `.next/server/app/**` (이미지 첨부)
- 클라이언트 컴포넌트(“use client”): `.next/static/chunks/**` (이미지 생략)

![서버컴포넌트 위치](/images/nextjs-rsc/server-component-position.webp)

이 구조 덕분에 서버에서 사전에 렌더링한 결과(RSC Payload)를 클라이언트에 전달하게 되어 별도의 JS를 필요로 하지 않게 됩니다.

이러한 구조는 클라이언트 JS 번들 최적화와도 직접적으로 연결됩니다.

### 클라이언트 JS 번들 최적화

지금까지 본 것처럼 서버는 HTML과 RSC Payload를 내려주고, 클라이언트는 이를 받아 Hydration을 진행합니다. 이때 모든 컴포넌트가 클라이언트 번들을 필요로 하는 것은 아닙니다.

- 서버 컴포넌트는 브라우저에서 실행되지 않으므로 JS 번들에 포함되지 않습니다.
- 클라이언트 컴포넌트만 실제 브라우저에 필요한 JS 코드가 번들링됩니다.

따라서 페이지 전체를 클라이언트 컴포넌트로 작성하던 Next.js 12 시절보다, Next.js 13(Server Components)에서는 번들 크기를 크게 줄일 수 있습니다. 이 메커니즘이 “JS 번들 크기 최적화”의 핵심 원리입니다.

### 정리

정리하자면, Next.js 13에서 도입된 서버 컴포넌트는 서버와 클라이언트의 역할을 명확히 분리해 번들 크기를 줄이고, 스트리밍 렌더링을 통해 빠른 초기 화면을 제공하며, 필요한 클라이언트 컴포넌트만 하이드레이션하여 상호작용을 가능하게 합니다.
이러한 구조는 성능 최적화뿐 아니라 개발자가 컴포넌트의 실행 환경을 의도적으로 설계할 수 있게 해주는 중요한 도구라고 할 수 있습니다.

그동안 저는 서버 컴포넌트가 번들에 포함되지 않고 서버에서 렌더링되어 HTML로 전달된다는 정도만 알고 있었습니다. 하지만 이번에 내용을 정리하면서 단순한 결과가 아닌 실제 동작 메커니즘을 이해할 수 있었고, 이를 통해 프레임워크를 한층 더 깊이 바라볼 수 있는 계기가 되었습니다.
