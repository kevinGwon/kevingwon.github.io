---
title: "Next.js에서 서버 컴포넌트를 어떻게 읽고 화면에 렌더링을 할까?"
date: "2025-09-04"
tags: ["Next.js", "React", "ServerComponent", "RSC Payload"]
layout: "../../components/Layout.astro"
---

> Next.js에서 서버 컴포넌트를 어떻게 읽고 화면에 렌더링을 할까?

---

### 이 내용을 선정하게 된 이유

Next.js 에서 서버 컴포넌트를 사용하면 여러 이점들을 공식 문서나 블로그에서 찾아볼 수 있습니다. 저는 이중에서 "JS 번들 크기 줄이기" 의 메커니즘이 궁금해졌고 어떤 방식으로 렌더링 되는지 궁금해졌습니다.

### 서버 컴포넌트가 무엇인지 간략하게 알아볼게요

서버 컴포넌트란 브라우저 레벨에서 렌더링되는 컴포넌트와 달리 서버에서 컴포넌트를 읽어 HTML 로 변환 후 클라이언트로 전달되는 컴포넌트를 의미합니다. 서버에서 리엑트 컴포넌트를 읽는다고? 의문이 들 수 있습니다. 이 시점에 "RSC Payload" 라는 개념이 등장하는데요 자세히 분석해보겠습니다.

### RSC(React server component) Payload

RSC Payload는 렌더링된 서버 컴포넌트의 압축된 바이너리 표현입니다. 개발 하다보면 네트워크 탭에서 `https://domain.com?_rsc=194na` 와 같은 요청으로 응답값을 다음과 같은 형태로 확인한 경험이 있을겁니다.

```ts
["$", "div", null, ["$", "h1", null, "List"], ["$C", "List", {}]];
```

RSC Payload는 클라이언트로 응답값이 전달되고 클라이언트측 리엑트에서 RSC Payload를 읽어 브라우저 DOM 을 업데이트 하는데 사용됩니다. RSC Payload 는 다음 내용을 포함하고 있습니다.

- 서버 컴포넌트 렌더링 결과
- 클라이언트에 위치할 정보, JS 파일 참조 정보
- 컴포넌트로 전달되는 props 정보

참조: [What is the React Server Component Payload (RSC)?](https://nextjs.org/docs/app/getting-started/server-and-client-components#on-the-server)

Next.js 13 버전부터 서버 컴포넌트를 선택적으로 구성할 수 있고 RSC Payload 표현이 가능해지면서 스트리밍 렌더링을 지원하여 사용자에게 빠른 컨텐츠를 제공할 수 있습니다. (+근거 필요)

Next.js 12 버전의 경우 클라이언트 중심으로만 컴포넌트 구성이 가능하여 스트리밍 렌더링과 같은 전략을 제공할 수 없습니다.

### 렌더링 과정

지금까지 RSC Payload가 무엇인지 간략하게 살펴보았는데요, 그럼 SEO에 제공되는 HTML 정보는 언제 생성될까요?

1. 서버 컴포넌트 실행 → RSC Payload 생성

   - 서버는 React Server Components를 실행하면서 클라이언트 컴포넌트 경계, props, 데이터 등을 Flight 포맷으로 직렬화하여 RSC Payload를 생성합니다.
   - 이 Payload는 브라우저가 클라이언트 컴포넌트를 동적으로 로드하고, 상호작용을 이어가기 위한 용도입니다.
   - SEO 크롤러는 이 Payload를 직접 읽지 못합니다.

2. 서버에서 HTML 스트리밍 생성 (`renderToPipeableStream`)

   - 동시에 서버는 동일한 서버 컴포넌트 트리를 기반으로 SEO에 필요한 HTML shell을 renderToPipeableStream을 통해 스트리밍합니다.
   - 이때 Suspense 경계를 기준으로, Fallback → 준비된 블록 순으로 HTML이 조각 단위로 흘러갑니다.
   - 따라서 브라우저/크롤러는 초기 HTML을 즉시 받아 빠른 FCP(First Contentful Paint)를 얻을 수 있습니다.

3. RSC Payload + 클라이언트에서 하이드레이션

   - 브라우저는 서버가 내려준 HTML을 즉시 렌더링한 뒤, RSC Payload를 fetch하여 필요한 클라이언트 컴포넌트를 로드합니다.
   - React는 이 Payload와 클라이언트 JS 번들을 조합해 기존 HTML을 hydrate하여 상호작용이 가능하도록 만듭니다.

React 18부터 추가된 `renderToPipeableStream` 은 Next.js 13 내부에서도 동일하게 동작합니다. 이 메커니즘 덕분에 서버 컴포넌트 기반으로 HTML을 빠르게 생성하여 SEO 대응이 가능하고, 동시에 RSC Payload를 통해 상호작용 가능한 클라이언트 UI를 이어갈 수 있습니다.

```tsx
import { renderToPipeableStream } from "react-dom/server";

const { pipe } = renderToPipeableStream(<App />, {
  bootstrapScripts: ["/main.js"],
  onShellReady() {
    response.setHeader("content-type", "text/html");
    pipe(response);
  },
});
```

참조

- [How to upgrade to version 13](https://nextjs.org/docs/pages/guides/upgrading/version-13)
- [renderToPipeableStream](https://ko.react.dev/reference/react-dom/server/renderToPipeableStream)

### 서버컴포넌트 위치

지금까지 클라이언트에 RSC Payload 가 어떻게 전달되는지 과정을 살펴보았는데요, 그럼 서버컴포넌트는 번들JS에 포함되지 않는다면 어디에 존재하고 있었을까요? 바로 빌드타임에 서버컴포넌트와 클라이언트컴포넌트 경계를 나누어서 저장하게 됩니다.

- 서버 컴포넌트(RSC): `.next/server/app/**`
- 클라이언트 컴포넌트(“use client”): `.next/static/chunks/**`

이 구조 덕분에 서버에서 사전에 렌더링한 결과(RSC Payload)를 클라이언트에 전달하게되어 별도의 JS 를 필요하지 않게 됩니다.

### 클라이언트 JS 번들 최적화

지금까지 본 것처럼 서버는 HTML과 RSC Payload를 내려주고, 클라이언트는 이를 받아 Hydration을 진행합니다.
이때 모든 컴포넌트가 클라이언트 번들을 필요로 하는 것은 아닙니다.

- 서버 컴포넌트는 브라우저에서 실행되지 않으므로 JS 번들에 포함되지 않습니다.
- 클라이언트 컴포넌트만 실제 브라우저에 필요한 JS 코드가 번들링됩니다.

따라서 페이지 전체를 클라이언트 컴포넌트로 작성하던 Next.js 12 시절보다, Next.js 13(Server Components)에서는 번들 크기를 크게 줄일 수 있습니다.
이 메커니즘이 “JS 번들 크기 최적화”의 핵심 원리입니다.
